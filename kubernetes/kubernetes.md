## Kubernetes
The Platform for applications.

**Dictionary**
| Component Name | Description |
| --- | --- |
| Pod | The smallest and simplest unit in the Kubernetes object model. Represents a single instance of a running process in your cluster. |
| Replication Controller | Ensures that a specified number of replicas of your application are running at any given time. |
| Deployment | An abstract way to manage Replication Controllers and Pods. |
| Service | An abstract way to expose your applications running on a set of Pods as a network service. |
| Volume | A way to persist data generated by and used by containers. |
| Namespace | A virtual cluster or sub-cluster within a cluster. Can be used for partitioning and isolation of resources in a cluster. |
| ConfigMap | A way to store configuration data that can be consumed by Pods and other parts of the system. |
| Secret | A way to store sensitive information, such as passwords, OAuth tokens, and SSH keys. |
| StatefulSet | Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. |
| DaemonSet | Ensures that a copy of a Pod is running on every node in the cluster. |
| Job | A single run to completion workload that can run one or more Pods. |
| Scheduler | The component that assigns Pods to nodes based on their resource requirements and constraints. |
| kube-api | The component that exposes the Kubernetes API. |
| kube-proxy | A network proxy that runs on each node in the cluster, responsible for forwarding traffic to the correct target Pod. |
| kubelet | Node managment service. |
| Control Plane | Managment server |
| Nodes | Worker servers |
| ETCD | Database with all information about cluster. Type NoSQL key=vaule |

# Install Kubernetes
**For Debian/Ubuntu**

These are the basic steps to install a Kubernetes cluster on an Ubuntu Server.
```sh
# Step 1: Update the system package index and upgrade the system packages
sudo apt-get -y update && sudo apt-get -y upgrade

# Step 2: Install Docker
sudo apt-get install -y docker.io

# Step 3: Add the Kubernetes signing key
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -

# Step 4: Add the Kubernetes repository to your sources list
echo "deb https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee -a /etc/apt/sources.list.d/kubernetes.list

# Step 5: Update the package index and install Kubernetes
sudo apt-get update
sudo apt-get install -y kubeadm kubelet kubectl

# Step 6: Enable the Docker and Kubernetes services
sudo systemctl enable docker && sudo systemctl start docker
sudo systemctl enable kubelet && sudo systemctl start kubelet

# Step 7: Initialize the Kubernetes cluster
sudo kubeadm init

# Step 8: Copy the generated kubeadm join command and save it for later use

# Step 9: Configure kubectl to use the new cluster
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

```

# Clusters
- minikube (all in one machine)
- mid-cluste (e.g. 1 control plane, a few nodes)
- HA (e.g. 3-7 control plane, etcd db outside, diffrent zones)

# Namespaces
What for? Mostly for isolation projects in k8s cluster.
| Destination | Description |
|-------------|-------------|
| Default     | All resources created  by users. |
| System      | The system namespace is reserved for objects created and used by the Kubernetes system itself. |
| kube-public | It is a set of objects, such as ConfigMaps, that are readable by all users, e.g. security tasks |
| kube-system | It is the namespace where all components of the Kubernetes system are installed. |

# Pods
What for? The Bigger container for smaller containers. Pods contains e.g. storage, subnet, ports, etc.

The pod may include one or more containers. For example the main cotnainer with app files and other with db. Or main container and second with logging system.

Static Pod is a special type of pod in the Kubernetes system that is directly managed by the cluster API controller, rather than the Scheduler. This means that the state of the pod is defined in a YAML file and is directly synchronized with the cluster API, rather than being decided by the Scheduler, which decides where to place the pod on a node.

## Most useful commands
```sh
# Help
kubectl --help

# Run new pod
kubectl run nginx --image nginx

# Delete pod
kubectl delete pod nginx

# Show details
kubectl describe pod nginx

# Show logs
kubectl logs nginx

# Test pod with port-forward. ONLY FOR TESTING
kubectl port-forward nginx HOST_PORT:POD_PORT 

# Show all pods
kubectl get pod

# Show template
kubectl run nginx --image nginx --dry-run -o yaml

# Run pod from template
kubectl apply -f FILE_NAME

# Exec pod
kubectl exec -ti nginx bash
```

# Replica set
A ReplicaSet in Kubernetes is a controller that ensures a specified number of replica pods are running in the cluster at any given time. This means that if any of the pods fail or are deleted, the ReplicaSet will automatically start a new pod to maintain the desired number of replicas.

Create example.replicaset.yaml
```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: frontend
  labels:
    app: guestbook
    tier: frontend
spec:
  # modify replicas according to your case
  replicas: 3
  selector:
    matchLabels:
      tier: frontend
  template:
    metadata:
      labels:
        tier: frontend
    spec:
      containers:
      - name: php-redis
        image: nginx
```
Check results:
```sh
# Run a replicaset
kubectl apply -f example.replicaset.yaml

# Get replicaset
kubectl get rs
```
