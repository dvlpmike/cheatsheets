## Kubernetes
The Platform for applications.

**Dictionary**
| Component Name | Description |
| --- | --- |
| Pod | The smallest and simplest unit in the Kubernetes object model. Represents a single instance of a running process in your cluster. |
| Replication Controller | Ensures that a specified number of replicas of your application are running at any given time. |
| Deployment | An abstract way to manage Replication Controllers and Pods. |
| Service | An abstract way to expose your applications running on a set of Pods as a network service. |
| Volume | A way to persist data generated by and used by containers. |
| Namespace | A virtual cluster or sub-cluster within a cluster. Can be used for partitioning and isolation of resources in a cluster. |
| ConfigMap | A way to store configuration data that can be consumed by Pods and other parts of the system. |
| Secret | A way to store sensitive information, such as passwords, OAuth tokens, and SSH keys. |
| StatefulSet | Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. |
| DaemonSet | Ensures that a copy of a Pod is running on every node in the cluster. |
| Job | A single run to completion workload that can run one or more Pods. |
| Scheduler | The component that assigns Pods to nodes based on their resource requirements and constraints. |
| kube-api | The component that exposes the Kubernetes API. |
| kube-proxy | A network proxy that runs on each node in the cluster, responsible for forwarding traffic to the correct target Pod. |
| kubelet | Node managment service. |
| Control Plane | Managment server |
| Nodes | Worker servers |
| ETCD | Database with all information about cluster. Type NoSQL key=vaule |

# Install Kubernetes
**For Debian/Ubuntu**

These are the basic steps to install a Kubernetes cluster on an Ubuntu Server.
```sh
# Step 1: Update the system package index and upgrade the system packages
sudo apt-get -y update && sudo apt-get -y upgrade

# Step 2: Install Docker
sudo apt-get install -y docker.io

# Step 3: Add the Kubernetes signing key
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -

# Step 4: Add the Kubernetes repository to your sources list
echo "deb https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee -a /etc/apt/sources.list.d/kubernetes.list

# Step 5: Update the package index and install Kubernetes
sudo apt-get update
sudo apt-get install -y kubeadm kubelet kubectl

# Step 6: Enable the Docker and Kubernetes services
sudo systemctl enable docker && sudo systemctl start docker
sudo systemctl enable kubelet && sudo systemctl start kubelet

# Step 7: Initialize the Kubernetes cluster
sudo kubeadm init

# Step 8: Copy the generated kubeadm join command and save it for later use

# Step 9: Configure kubectl to use the new cluster
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

```

# Clusters
- minikube (all in one machine)
- mid-cluste (e.g. 1 control plane, a few nodes)
- HA (e.g. 3-7 control plane, etcd db outside, diffrent zones)

# Namespaces
What for? Mostly for isolation projects in k8s cluster.
| Destination | Description |
|-------------|-------------|
| Default     | All resources created  by users. |
| System      | The system namespace is reserved for objects created and used by the Kubernetes system itself. |
| kube-public | It is a set of objects, such as ConfigMaps, that are readable by all users, e.g. security tasks |
| kube-system | It is the namespace where all components of the Kubernetes system are installed. |

# Pods
What for? The Bigger container for smaller containers. Pods contains e.g. storage, subnet, ports, etc.

The pod may include one or more containers. For example the main cotnainer with app files and other with db. Or main container and second with logging system.

Static Pod is a special type of pod in the Kubernetes system that is directly managed by the cluster API controller, rather than the Scheduler. This means that the state of the pod is defined in a YAML file and is directly synchronized with the cluster API, rather than being decided by the Scheduler, which decides where to place the pod on a node.

# Most useful commands
```sh
# Help
kubectl --help

# Run new pod
kubectl run nginx --image nginx

# Delete pod
kubectl delete pod nginx

# Show details
kubectl describe pod nginx

# Show logs
kubectl logs nginx

# Test pod with port-forward. ONLY FOR TESTING
kubectl port-forward nginx HOST_PORT:POD_PORT 

# Show all pods
kubectl get pod

# Show template
kubectl run nginx --image nginx --dry-run -o yaml

# Run pod from template
kubectl apply -f FILE_NAME

# Exec pod
kubectl exec -ti nginx bash
```

# Replica set
A ReplicaSet in Kubernetes is a controller that ensures a specified number of replica pods are running in the cluster at any given time. This means that if any of the pods fail or are deleted, the ReplicaSet will automatically start a new pod to maintain the desired number of replicas.

Create example.replicaset.yaml:
```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: frontend
  labels:
    app: guestbook
    tier: frontend
spec:
  # modify replicas according to your case
  replicas: 3
  selector:
    matchLabels:
      tier: frontend
  template:
    metadata:
      labels:
        tier: frontend
    spec:
      containers:
      - name: php-redis
        image: nginx
```
Check results:
```sh
# Run a replicaset
kubectl apply -f example.replicaset.yaml

# Get a replicaset
kubectl get rs

# Get a pod with custom columns
kubectl get pod -o custom-columns=CONTAINER:.metadata.name,IMAGE:".spec.containers[0].image" 
```

# Deployment
A Deployment provides declarative updates for Pods and ReplicaSets.

| Strategy | Description |
|---|---|
| Rolling Update | Gradually replaces the old version of an application with a new one by creating new instances, waiting for them to become ready, and then terminating the old instances. Allows for zero-downtime updates and can be customized. |
| Recreate | Terminates all instances of the old version of an application and creates new instances of the new version. Results in a brief downtime but can be useful for certain situations. |

Create deployment file:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
```
Run deployment:
```sh
kubectl apply -f deployment.yaml

# Get pods
kubectl get pods

# Get deployments
kubectl get deploy
```
Scale deployment:
```sh
kubectl scale deployment/nginx-deployment --replicas=5
```

# Service
| Kubernetes Service | Description |
| --- | --- |
| ClusterIP | Exposes the service on a cluster-internal IP address, making it accessible within the cluster but not from outside the cluster. This is the default service type. |
| NodePort | Exposes the service on a static port on each node's IP address, making it accessible from outside the cluster. This is useful for development and testing but not recommended for production use. |
| LoadBalancer | Exposes the service externally using a cloud provider's load balancer. The load balancer will route traffic to the nodes running the service. |
| ExternalName | Maps the service to the contents of the externalName field (e.g., a DNS name), allowing the service to act as a proxy to an external service. |
| Headless | Creates a service without a cluster-internal IP address, allowing direct access to the pods behind the service. This is useful for stateful applications that require stable network identities. |
